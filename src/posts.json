{
  "2019": {
    "11": {
      "27": {
        "title": "Olá mundo!",
        "description": "Primeiro post do blog!",
        "content": "## Nada melhor do que começar com o clichê: *Olá mundo!* \n\n Bem cá estou eu, começando o primeiro post desse blog :) \n Como parte da nota final de uma disciplina da faculdade era escrever um artigo, pensei que seria uma boa ideia criar um blog para documentar o que vou aprender/aprendi durante os anos como rebocador da web. Para iniciar, peguei algumas perguntas de um FAQ para responder: \n \n # Quem sou eu? \n *Antonio* Eduardo Moreira, uma mistura de paulista com paranaense, 19 aninhos, acadêmico do curso de tecnologia em sistemas para internet na UTFPR, campus Guarapuava. Atualmente trabalho na Codeminer42 predominantemente no Front-End. \n \n # Por que começou a codar? \n Bom, eu sempre gostei bastante de tecnologia no geral, e no final de 2017, no final do ensino médio, acabei escolhendo uma faculdade que me trouxe até aqui. Conheci muitas pessoas que me ensinaram grande parte das coisas que sei hoje, e sou bastante feliz com a profissão. \n \n # Back ou front? \n Como comentei acima, atualmente na Codeminer, eu sou mais front, trabalhando bastante com react (esse blog também é feito em react por sinal), mas na minha empresa antiga eu era mais back do que front. Afinal de contas eu gosto dos dois, é mais uma questão de 'fase'. \n \n # Primeira linguagem? \n Eu comecei mesmo a programar de fato na faculdade, e como na maioria das faculdades, eles apresentam para os alunos Java, comigo não foi diferente, comecei com Java, confesso que tenho um certo amor e ódio pela linguagem. \n \n # Linguagem favorita? \n Eu não tenho uma linguagem favorita, na empresa antiga eu trabalhava praticamente 100% do tempo com PHP, atualmente mexo muito pouco com PHP, mais JavaScript e Ruby. Gosto bastante dessas comunidades do JS e Ruby. \n \n Acho que era isso, em breve pretendo postar coisas mais técnicas, desde já, valeu!",
        "images": [],
        "tags": []
      }
    },
    "12": {
      "03": {
        "title": "Atualizações em tempo real com WebSocket!",
        "description": "Funcionamento de websocket dentro do spring",
        "content": "Ao longo dos anos, a web juntamente da tecnologia veio evoluindo cada vez mais. O paradigma convencional no estilo request/response via protocolo HTTP resolve grande parte dos nossos problemas. Em meados de 2005, as tão famosas chamadas *Ajax*\nsurgiram, e na época foram simplesmente uma revolução, pois antes delas existirem não era possível atualizar dados de uma\n página da web sem fazer com que o usuário recarregasse sua página, a idéia de fazer requisições dessa forma era genial!\n\nO tempo foi passando e as famosas chamadas *Ajax* deixaram de ser 'de outro mundo', diversos softwares passaram a utilizar e isso passou fazer parte do nosso cotidiano. As chamadas *Ajax* tinham um grave problema que era o alto custo em manter as informações atualizadas, pois a responsabilidade de atualização de dados ficava toda do lado do cliente, pois a requisição era lançada a partir da máquina dele, dessa forma, o problema do modelo request/response foi parcialmente solucionado.\n\nA partir de todos esses problemas e também de uma necessidade do mercado, surgiu o *WebSocket*, uma tecnologia avançada que permitia fazer atualizações em tempo real através do protocolo TCP. A comunicação entre cliente e servidor é feito através de uma sessão de comunicação interativa, e por parte do cliente não é tão custosa quanto as chamadas *Ajax*.\n\n## Resumindo\n\n Sabe quando chega uma notificação em algum site ou simplesmente um chat de atendimento em tempo real? Então, a chance de por trás disso ter um WebSocket é alta, pois atualmente existem diversos modelos e linguagens que abordam o WebSocket de forma bastante simples, e no ecossistema Spring, não é diferente! \n \n## Mãos a obra?\n\nA seguir temos um breve passo a passo de como dar início a um aplicativo web interativo que fará o uso do WebSocket. Vale ressaltar que a troca de informações através do WebSocket serão todas feitas via JSON, o que facilita a manipulação.\n\nComece o processo pensando em interações de serviço. O serviço aceitará mensagens contendo um nome em uma mensagem STOMP cujo corpo é um objeto JSON. Se o nome fornecido for 'Fred', a mensagem poderá ser algo como isto:\n\n`{\n'name': 'Fred'\n}\n`\n\nE a partir dessa simples informação que pode ser enviada via WebSocket pode ser gerada diversas aplicações, como por exemplo uma sala de chat, onde quando um usuário se conectar apresentar que ele entrou.\n\n Para modelar a mensagem que leva o nome, você pode criar um objeto Java simples:\n\n```\npublic class HelloMessage {\n\tprivate String name;\n\n\tpublic HelloMessage() { }\n\n \tpublic HelloMessage(String name) {\n \t\tthis.name = name;\n\t}\n\n \tpublic String getName() {\n \t\treturn name;\n\t}\n\n \tpublic void setName(String name) {\n \t\tthis.name = name;\n\t}\n}\n```\n\n Ao receber a mensagem e extrair o nome, o serviço a processará criando uma saudação e publicando essa saudação em uma fila separada na qual o cliente está inscrito. A saudação também será um objeto JSON, que pode ser algo como isto:\n\n`\n{\n'content': 'Hello,Fred!'\n}\n`\n\nO Spring usará a biblioteca [JSON Jackson](https://www.baeldung.com/jackson) para organizar automaticamente instâncias do tipo 'saudação' no JSON. Em seguida, você criará um controlador para receber a mensagem de saudação e enviar uma mensagem de saudação.\n\n## Criar um controlador de manipulação de mensagens\n\nNa abordagem do Spring para trabalhar com mensagens STOMP, as mensagens STOMP podem ser roteadas para as @GreetingController. Por exemplo, o GreetingController será mapeado para manipular mensagens para o destino '/hello'.\n\n```\n\timport org.springframework.messaging.handler.annotation.MessageMapping;\n\timport org.springframework.messaging.handler.annotation.SendTo;\n\timport org.springframework.stereotype.Controller;\n\timport org.springframework.web.util.HtmlUtils;\n\n\t@Controller\n\tpublic class GreetingController {\n\t\t@MessageMapping('/hello')\n\t\t@SendTo('/topic/greetings')\n\t\tpublic Greeting greeting(HelloMessage message) throws Exception {\n\t\t\tThread.sleep(1000); // simulando um delay \n\t\t\treturn new Greeting('Hello, ' + HtmlUtils.htmlEscape(message.getName()) + '!');\n\t\t}\n\t}\n```\n\nEste controlador é conciso e simples, mas há muita coisa acontecendo. Vamos dividir passo a passo.\nA @MessageMapping garante que, se uma mensagem for enviada para o destino '/hello', o greeting() método será chamado.\n\nA carga útil da mensagem está vinculada a um HelloMessage objeto que é passado para greeting().\n\nInternamente, a implementação do método simula um atraso no processamento, fazendo com que o encadeamento entre em repouso por 1 segundo. Isso é para demonstrar que, depois que o cliente envia uma mensagem, o servidor pode demorar o tempo necessário para processar a mensagem de forma assíncrona. O cliente pode continuar com o trabalho que precisa realizar sem aguardar a resposta.\n\nApós o atraso de 1 segundo, o greeting() cria um objeto Greeting e o retorna. O valor de retorno é transmitido a todos os assinantes para '/topic/greetings', conforme especificado na @SendTo. Observe que o nome da mensagem de entrada é higienizado, pois, nesse caso, ele será repetido e renderizado novamente no DOM do navegador no lado do cliente.\n\n## Configurar o Spring para mensagens STOMP\n\nAgora que os componentes essenciais do serviço foram criados, você pode configurar o Spring para ativar as mensagens WebSocket e STOMP.\n\nCrie uma classe Java chamada WebSocketConfig:\n\n```@Configuration\n\t@EnableWebSocketMessageBroker\n\tpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n\t\t@Override\n\t\tpublic void configureMessageBroker(MessageBrokerRegistry config) {\n\t\t\tconfig.enableSimpleBroker('/topic');\n\t\t\tconfig.setApplicationDestinationPrefixes('/app');\n\t\t}\n\n\t\t@Override\n\t\tpublic void registerStompEndpoints(StompEndpointRegistry registry) { \n\t\t\tregistry.addEndpoint('/gs-guide-websocket').withSockJS();\n\t\t}\n\t}\n```\n\n WebSocketConfig é anotado com @Configuration para indicar que é uma classe de configuração do Spring. Também é anotado @EnableWebSocketMessageBroker. Como o próprio nome sugere, @EnableWebSocketMessageBroker habilita o tratamento de mensagens do WebSocket, suportado por um intermediário de mensagens.\n\nO configureMessageBroker() implementa o método padrão WebSocketMessageBrokerConfigurer para configurar o intermediário de mensagens. Ele começa chamando enableSimpleBroker() para permitir que um simples intermediário de mensagens baseado em memória leve as mensagens de saudação de volta ao cliente em destinos prefixados com '/topic'. Ele também designa o prefixo '/app' para mensagens vinculadas a @MessageMapping não anotados. Esse prefixo será usado para definir todos os mapeamentos de mensagens; por exemplo, '/app/hello' é o terminal que o GreetingController.greeting() está mapeado para manipular.\n\nO registerStompEndpoints() registra o terminal '/gs-guide-websocket', ativando as opções de fallback do SockJS para que transportes alternativos possam ser usados ​​se o WebSocket não estiver disponível. O cliente SockJS tentará se conectar ao '/ gs-guide-websocket' e usará o melhor transporte disponível (websocket, xhr-streaming, xhr-polling, etc.).\n\n## Lado do cliente\n\nCom as peças do lado do servidor, agora vamos voltar a atenção para o cliente JavaScript que enviará e receberá mensagens do lado do servidor. Você precisará importar também do lado do cliente, as bibliotecas javascript SockJS e STOMP que serão usadas para se comunicar com nosso servidor usando o STOMP no websocket.\n\nE usando JQuery o funcionamento seria basicamente assim:\n\n\n```\n\tvar stompClient = null;\n\n\tfunction connect() {\n\t\tvar socket = new SockJS('/gs-guide-websocket');\n\t\tstompClient = Stomp.over(socket);\n\t\tstompClient.connect({}, function (frame) {\n\t\t\tsetConnected(true);\n\t\t\tconsole.log('Connected: ' + frame);\n\t\t\tstompClient.subscribe('/topic/greetings', function (greeting) {\n\t\t\t\tshowGreeting(JSON.parse(greeting.body).content);\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction disconnect() {\n\t\tif (stompClient !== null) {\n\t\t\tstompClient.disconnect();\n\t\t}\n\t\tsetConnected(false);\n\t\tconsole.log('Disconnected');\n\t}\n\n\tfunction sendName(name) {\n\t\tstompClient.send('/app/hello', {}, JSON.stringify({ name }));\n\t}\n\n```\nA parte principal deste arquivo JavaScript a ser observada é as funções connect() e sendName().\n\nA connect() função usa SockJS e stomp.js para abrir uma conexão com '/gs-guide-websocket', que é onde nosso servidor SockJS está aguardando conexões. Após uma conexão bem-sucedida, o cliente assina o destino '/topic/greetings', onde o servidor publicará mensagens de saudação.\n\nA sendName() função recebe um nome e usa o cliente STOMP para enviá-lo ao destino '/app/hello' (onde GreetingController.greeting() o receberá).\n\n ## Concluindo \n\nA partir desse exemplo acima, é possível construir várias aplicações interessantes e relativamente simples em questão de arquitetura graças ao ecossistema Spring que aborda de forma bastante inteligente o WebSocket. O conteúdo base desse artigo foi traduzido e inspirado diretamente da documentação oficial do Spring, que você pode checar [clicando aqui](https://spring.io/guides/gs/messaging-stomp-websocket/). Muito obrigado e até a próxima!",
        "images": [],
        "tags": ["spring","java","websocket"]
      }
    }
  }
}
